{"version":3,"sources":["webpack:///path---hope-saves-the-world-c296db6cfe1c46739f94.js","webpack:///./.cache/json/hope-saves-the-world.json"],"names":["webpackJsonp","446","module","exports","data","markdownRemark","html","frontmatter","title","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,u/DAAAC,aAA6gEC,MAAA,sBAA6BC,aAAgBC,KAAA","file":"path---hope-saves-the-world-c296db6cfe1c46739f94.js","sourcesContent":["webpackJsonp([245572372745769],{\n\n/***/ 446:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>As the requirements for JavaScript single-page applications have become\\nincreasingly complicated, our code must manage more state than ever before. This\\nstate can include server responses and cached data, as well as locally created\\ndata that has not yet been persisted to the server. UI state is also increasing\\nin complexity, as we need to manage active routes, selected tabs, spinners,\\npagination controls, and so on.</p>\\n<p>Managing this ever-changing state is hard. If a model can update another model,\\nthen a view can update a model, which updates another model, and this, in turn,\\nmight cause another view to update. At some point, you no longer understand what\\nhappens in your app as you have lost control over the when, why, and how of its\\nstate. When a system is opaque and non-deterministic, it's hard to reproduce\\nbugs or add new features.</p>\\n<p>As if this wasn't bad enough, consider the new requirements becoming common in\\nfront-end product development. As developers, we are expected to handle\\noptimistic updates, server-side rendering, fetching data before performing route\\ntransitions, and so on. We find ourselves trying to manage a complexity that we\\nhave never had to deal with before, and we inevitably ask the question: is it\\ntime to give up? The answer is no.</p>\\n<p>This complexity is difficult to handle as we're mixing two concepts that are\\nvery hard for the human mind to reason about: mutation and asynchronicity. I\\ncall them Mentos and Coke. Both can be great in separation, but together they\\ncreate a mess. Libraries like React attempt to solve this problem in the view\\nlayer by removing both asynchrony and direct DOM manipulation. However, managing\\nthe state of your data is left up to you. This is where Redux enters.</p>\\n<p>Following in the steps of Flux, CQRS, and Event Sourcing, Redux attempts to make\\nstate mutations predictable by imposing certain restrictions on how and when\\nupdates can happen. These restrictions are reflected in the three principles of\\nRedux.</p>\",\"frontmatter\":{\"title\":\"Redux simplified\"}}},\"pathContext\":{\"slug\":\"/hope-saves-the-world/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---hope-saves-the-world-c296db6cfe1c46739f94.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>As the requirements for JavaScript single-page applications have become\\nincreasingly complicated, our code must manage more state than ever before. This\\nstate can include server responses and cached data, as well as locally created\\ndata that has not yet been persisted to the server. UI state is also increasing\\nin complexity, as we need to manage active routes, selected tabs, spinners,\\npagination controls, and so on.</p>\\n<p>Managing this ever-changing state is hard. If a model can update another model,\\nthen a view can update a model, which updates another model, and this, in turn,\\nmight cause another view to update. At some point, you no longer understand what\\nhappens in your app as you have lost control over the when, why, and how of its\\nstate. When a system is opaque and non-deterministic, it's hard to reproduce\\nbugs or add new features.</p>\\n<p>As if this wasn't bad enough, consider the new requirements becoming common in\\nfront-end product development. As developers, we are expected to handle\\noptimistic updates, server-side rendering, fetching data before performing route\\ntransitions, and so on. We find ourselves trying to manage a complexity that we\\nhave never had to deal with before, and we inevitably ask the question: is it\\ntime to give up? The answer is no.</p>\\n<p>This complexity is difficult to handle as we're mixing two concepts that are\\nvery hard for the human mind to reason about: mutation and asynchronicity. I\\ncall them Mentos and Coke. Both can be great in separation, but together they\\ncreate a mess. Libraries like React attempt to solve this problem in the view\\nlayer by removing both asynchrony and direct DOM manipulation. However, managing\\nthe state of your data is left up to you. This is where Redux enters.</p>\\n<p>Following in the steps of Flux, CQRS, and Event Sourcing, Redux attempts to make\\nstate mutations predictable by imposing certain restrictions on how and when\\nupdates can happen. These restrictions are reflected in the three principles of\\nRedux.</p>\",\"frontmatter\":{\"title\":\"Redux simplified\"}}},\"pathContext\":{\"slug\":\"/hope-saves-the-world/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/hope-saves-the-world.json\n// module id = 446\n// module chunks = 245572372745769"],"sourceRoot":""}